---
title: "Predictions for Clint and fup using models presented in Dawson et al. 2021"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This R markdown script will allow a user to predict Fup and Clint values for chemicals based on the QSAR Models presented in Dawson et al. 2021: Designing QSARs for parameters of high throughput toxicokinetic models using open-source descriptors. Environmental Science and Technology. 

Data to accomplish this is contained in separate Clint and Fup folders, which each contain the random forest objects, and the means and standard deviations of the training set used to create the models. This script will read in novel chemicals for which predictors have been computed, standardize the parameters of the chemical according to the training set(s), and predict Clint and Fup for those chemicals. 

To fit predictions from the Clint and Fup models, you will need OPERA model predictions and PaDEL descriptions for your chemicals of interest. 

### OPERA predictors include:

"LogP"   "LogWS"  "LogBCF" "LogKM"  "MP"     "LogVP"  "LogD55" "LogD74" "LogOH" 

### PaDEL descriptors include:

 "CrippenLogP"       "nBase"             "XLogP"             "AATS1v"            "AATS0i"           
 "ETA_EtaP_F"        "ZMIC2"             "maxHBa"            "minsssN"           "AATS1i"           
 "ETA_dEpsilon_B"    "GATS1i"            "ZMIC1"             "SsssN"             "nAromBond"        
 "AATSC0p"           "minHBd"            "LipoaffinityIndex" "AATS3v"            "AATS2i"           
 "C2SP2"             "AATS4v"            "Kier2"             "AATS6m"            "AATS6v"           
 "minssCH2"          "AATS5v"            "AATS5i"            "ATSC2c"            "ATSC6c"           
 "ATSC3m"            "ATSC3e"            "AATSC0c"           "AATSC0v"           "MATS1c"           
 "MATS8c"            "GATS5c"            "GATS1e"            "GATS5e"            "BCUTc.1l"         
 "BCUTp.1l"          "BCUTp.1h"          "nBondsM"           "SpMin2_Bhm"        "SpMax2_Bhp"       
 "minHaaCH"          "minaaCH"           "IC1"               "MLFER_BH"          "piPC8"            
 "R_TpiPCTPC"     

These sets are included in the file "CombinedDescriptors_DED050621.RData", included in this folder. 

Several but not all needed OPERA predictors are available from the EPA CompTox Dashboard. However, PaDEL descriptors are not available at all from the dashboard.To calculate these descriptors for your data, we recommend downloading the OPERA(Open QSAR app) application from https://github.com/NIEHS/OPERA

The OPERA application is an open-source, stand-alone application that will produce both Opera predictions and PaDEL descriptions; Opera models are based entirely upon PaDEL descriptors and fingerprints. You will need either a chemical description ID(i.e., DTXSID,CASRN) or structural description(SMILES,MOL) for each chemical. Make sure to select all of the opera models you want, and select the "keep full descriptor files" box. This will generate and keep all calculations for all PaDEL descriptors, as well as your desired Opera predictors. Keep in mind that they may range from minutes to hours, depending on the number chemicals for which predictions are desired(10's to 1000's).   


If you want to use SMILES codes to run through the OPERA function, you can download them from the CompTox Dashboard. Then, you can write out the text file to be used in the OPERA application. Whatever data source you used, make sure there are no column headers or row number in your data file. For more information, read the documentation for data input into the OPERA application. 

By checking the "keep full descriptor files" box, OPERA will produce a lot of files you don't need. You only need the Opera predictions (with default suffix "_OPERA2.6Pred") and PaDEL descriptors (default suffix "_PadelDesc").  


# Read in data and prepare for prediction
Once the descriptors are calculated, load the files here, and prepare them to be used to make predictions. You have to make sure all of the descriptor names in your data match the descriptors used in the RF model objects. If you used SMILES codes, you also have make sure that the molecule ID output from Opera aligns with the DTXSID or CASRN of the chemicals in your set.  

In the example below, we use the Tox21 dataset used to produce predictions presented in the paper. We downloaded the smiles codes from the Comptox Dashboard ("Tox21_FromCompToxDashboard.xlsx") through the OPERA application. Then we loaded the OPERA descriptors and PaDEL descriptors produced from the OPERA application, and a combined list of OPERA and PaDEL descriptors used in both the Clint and fup models. We then create a combined set of Opera and Padel descriptors based on their DTXSID's. Note that if you only load SMILES into the OPERA application without a CAS or DTXSID, you have to align the molecule ID with the SMILES at this step. This is important in the case that either PaDEL or Opera predictors can't be calculated for a given chemical, and you end up with a missing chemical in the Opera prediction file.  


## LOAD PACKAGES
```{r}
packages=c("openxlsx", "randomForest", "stringr")
sapply(packages, require, character.only=TRUE)
```


```{r}
Operaversion=2.6
Datalabel="Tox21"
chemlist=read.xlsx("ExampleData/Tox21_FromCompToxDashboard.xlsx")
chemlist$rowid=seq(1,nrow(chemlist),1)
load("CombinedDescriptors_DED050621.RData")#descriptors in both models
Descriptors$Opera=paste0(Descriptors$Opera, "_pred")
Opera=read.csv("ExampleData/Tox21_QSAR_SMILES-smi_OPERA2.6Pred.csv")
Padel=read.csv("ExampleData/Tox21_QSAR_SMILES_QSAR-ready_smi_PadelDesc.csv")
Opera=Opera[,c(1,which(names(Opera)%in%Descriptors$Opera))]
Padel=Padel[,c(1,which(names(Padel)%in%Descriptors$Padel))]


#Merge with truncated opera and padel lists
chemlist=merge(Opera, Padel, by.x="MoleculeID", by.y="Name", all.x=TRUE)
desccols=which(names(chemlist)%in%Descriptors$Padel | names(chemlist)%in%Descriptors$Opera)
Descnames=names(chemlist)[desccols]

```

# Intrinsic Clearance (Clint)
Read in clint model object and training data mean and std. 
Normalize your data using the training data. Then, use the predict function to predict clint bin. Use the training data from the included Revised S2 file from the Dawson et al. 2021 paper to calculate the bin median values. Finally, determine whether clint predictions are in or out of the AD, using the the method from Roy et al. 2015. 

```{r}
load("Clint/ClintModel_3Bin_040121.RData")
msd=read.csv("Clint/mean_std_training_descriptors_DED021621.csv")
submsd=msd[,which(names(msd)%in%names(chemlist))]

##Standardize by training set mean and sd 
chemlistsc=chemlist
for(i in Descnames){
  sub1=subset(submsd, select=c(names(submsd)==i))  
  chemlistsc[,i]=(chemlist[,i]-sub1[1,1]) / sub1[2,1]
}

#Subset to only Clint model 
Clintmodvars=row.names(importance(ClintClass3Mod))
chemlistClintmodvars=which(names(chemlistsc)%in%Clintmodvars)

IDcolstart=1
IDcolend=1
chemlistsc_Clint=chemlistsc[,c(IDcolstart:IDcolend,chemlistClintmodvars)]

#Take out incomplete descriptors
ClintComplete=complete.cases(chemlistsc_Clint)
chemlistsc_Clint_narm=chemlistsc_Clint[which(ClintComplete==TRUE),]
IncompleteClint=chemlistsc[which(ClintComplete==FALSE),]
write.csv(IncompleteClint,file=paste0("Incomplete_Opera_PaDEL_Clint_predictions_",Datalabel,".csv"))

#Make Predictions
set.seed(1255)
chemlistpredictClint=predict(ClintClass3Mod,chemlistsc_Clint_narm)
chemlistsc_Clint_narm$ClintPredictBin=chemlistpredictClint

#Convert to clearance ul/10^6 hepatic cells based on training data 
training=read.xlsx("S2_Dawson et al. Supporting_Information_Revision_Final_Sharing.xlsx", sheet=3)
training$Bin3.Adj=ifelse(training$Bin3.Adj==4,3,training$Bin3.Adj)
tmeanagtable=aggregate(training$Clearance.Adj~training$Bin3.Adj, FUN="median")
tsdagtable=aggregate(training$Clearance.Adj~training$Bin3.Adj, FUN="sd")
chemlistsc_Clint_narm$ClintPredictBin_MD=ifelse(chemlistsc_Clint_narm$ClintPredictBin==1, tmeanagtable[1,2], ifelse(
                                                chemlistsc_Clint_narm$ClintPredictBin==2, tmeanagtable[2,2], tmeanagtable[3,2]))
chemlistsc_Clint_narm$ClintPredictBin_SD=ifelse(chemlistsc_Clint_narm$ClintPredictBin==1, tsdagtable[1,2], ifelse(
                                                chemlistsc_Clint_narm$ClintPredictBin==2, tsdagtable[2,2] ,tsdagtable[3,2]))



```


## Apply applicability domain 
Using methodology of Roy et al 2015, apply applicability domain of Clint model to predictions of new chemicals and export

```{r}
 a=chemlistsc_Clint_narm  
 b=a[,c("MoleculeID")]
 a=a[,which(names(a)%in%Clintmodvars)]
 a=abs(a)
 SImin=apply(a,1,min) #Find the min, max, sd, and mean
 SImax=apply(a,1,max)
 SImean=apply(a,1,mean)
 SIsd=apply(a,1,sd)
  
    
  #Several are NA when SD is calculated
  SIdf=data.frame(SImin, SImax, SImean, SIsd)
  SIdf$SI90=SIdf$SImean + (1.28 * SIdf$SIsd)
  SIdf$Outlier=0 #something is assumed to be inside the AD unless it it found to not be 

    #Based Algorithm specificed in Roy et al. 2015)
    for(i in 1:length(SIdf[,1])){
      if(SIdf$SImax[i]<3){ next } else 
        if (SIdf$SImin[i] > 3) {
          SIdf$Outlier[i] = 1 } else if 
      (SIdf$SImean[i] + (1.28 * SIdf$SIsd[i]) > 3){
        SIdf$Outlier[i]=1}
    }
    
chemlistsc_Clint_narm=data.frame(chemlistsc_Clint_narm, SIdf)
write.csv(chemlistsc_Clint_narm, file=paste0("Novel_clint_predictions_with_AD_",Datalabel,"_descs_from_Opera",Operaversion, ".csv"))
```

## Fraction unbound by plasma(fup)
Read in the fup model object and training data mean and std. 
Normalize your data using the training data. Then, use the predict function to predict fup values. After this, determine whether fup predictions
are in or out of the AD, using the the method from Roy et al. 2015. 
```{r}
fupchemlist=chemlist 
load("Fup/fup_RFmodel_30desc_select_by_sqrt_transform.RData")
fupmodvars=row.names(RF.fit$importance)
msd=read.csv("Fup/fup_mean_std_training_descriptors_DED052021.csv")

#substitute the correct names into the chemlist 
#Here, adapt descriptor names to the format expected in the fup random forest file. 
Padeldesc=which(names(fupchemlist)%in%str_remove(fupmodvars, 'padel_'))
Operadesc=which(str_remove(names(fupchemlist), "_pred")%in%str_remove(fupmodvars, 'Opera_'))
names(fupchemlist)=str_remove(names(fupchemlist), '_pred')

for(i in Padeldesc){names(fupchemlist)[i]=paste0("padel_",names(fupchemlist)[i])}
for(i in Operadesc){names(fupchemlist)[i]=paste0("Opera_",names(fupchemlist)[i])}

#Subset to only Fup model 
chemlistfupmodvars=which(names(fupchemlist)%in%fupmodvars)
IDcolstart=1
IDcolend=1
fupchemlist=fupchemlist[,c(IDcolstart:IDcolend,chemlistfupmodvars)]


##Standardize by training set mean and sd
chemlistfupsc=fupchemlist
for(i in fupmodvars){
  sub1=subset(msd, select=c(names(msd)==i))
  chemlistfupsc[,i]=(chemlistfupsc[,i]-sub1[1,1]) / sub1[2,1]
}

#Take out incomplete descriptors
fupscComplete=complete.cases(chemlistfupsc)
chemlistsc_fup_narm=chemlistfupsc[which(fupscComplete==TRUE),]
Incompletescfup=chemlistfupsc[which(fupscComplete==FALSE),]
write.csv(Incompletescfup,file=paste0("Incomplete_Opera_PaDEL_fup_predictions_",Datalabel,".csv"))


#Make Predictions
set.seed(1255)
chemlistpredictfup=predict(RF.fit,chemlistsc_fup_narm)
chemlistsc_fup_narm$Fup.RF.pred=chemlistpredictfup^2 #square-root transformation applied to model results. 
```


### Apply applicability domain 
Using methodology of Roy et al 2015, apply applicability domain of fup model to predictions of new chemicals and export
```{r}
 a=chemlistsc_fup_narm
 b=a[,c("MoleculeID")]
 a=a[,which(names(a)%in%fupmodvars)]
 a=abs(a)
 SImin=apply(a,1,min) #Find the min, max, sd, and mean
 SImax=apply(a,1,max)
 SImean=apply(a,1,mean)
 SIsd=apply(a,1,sd)


  #Several are NA when SD is calculated
  SIdf=data.frame(SImin, SImax, SImean, SIsd)
  SIdf$SI90=SIdf$SImean + (1.28 * SIdf$SIsd)
  SIdf$Outlier=0 #something is assumed to be inside the AD unless it it found to not be

    #Based Algorithm specificed in Roy et al. 2015)
    for(i in 1:length(SIdf[,1])){
      if(SIdf$SImax[i]<3){ next } else
        if (SIdf$SImin[i] > 3) {
          SIdf$Outlier[i] = 1 } else if
      (SIdf$SImean[i] + (1.28 * SIdf$SIsd[i]) > 3){
        SIdf$Outlier[i]=1}
    }

chemlistsc_fup_narm=data.frame(chemlistsc_fup_narm, SIdf)
write.csv(chemlistsc_fup_narm, file=paste0("Novel_fup_predictions_with_AD_", Datalabel,"_descs_from_Opera",Operaversion, ".csv"))
```

Data QC: Check the produced predictors against the data presented in the table 
```{r}
#Corrected table in paper
T21BER=read.xlsx("S2_Dawson et al. Supporting_Information_Revision_Final_Sharing.xlsx", sheet=14)

ClintPreds=read.csv(paste0("Novel_clint_predictions_with_AD_",Datalabel,"_descs_from_Opera",Operaversion, ".csv"))

fupPreds=read.csv(paste0("Novel_fup_predictions_with_AD_",Datalabel,"_descs_from_Opera",Operaversion, ".csv"))


#Check Clint and fup predictions
#Note that the table in S2.13 only includes chemicals with both Clint and fup QSAR predictions. Some chemicals, however, had either Clint or fup predictions, depending upon whether Opera or Padel calculations could be made for them. So, they need to be subset by the matching chemicals to check.  

#Check Clint predictions
ClintPreds=ClintPreds[which(ClintPreds$MoleculeID%in%T21BER$DTXSID==TRUE),] #Subset the Clint preds to the chemicals present in the table
cor(T21BER$QSAR_Clint, ClintPreds$ClintPredictBin_MD)

#Check fup predictions
fupPreds=fupPreds[which(fupPreds$MoleculeID%in%T21BER$DTXSID==TRUE),] #subset the fup prds to teh chemicals present in the table
cor(T21BER$QSAR_Fup, fupPreds$Fup.RF.pred)



```
